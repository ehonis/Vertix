generator client {
    provider = "prisma-client-js"
    output   = "./node_modules/.prisma/client"
}

datasource db {
    provider  = "postgresql"
    url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
    directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

enum Locations {
    ropeNorthWest
    ropeNorthEast
    ABWall
    ropeSouthWest
    ropeSouthEast
    boulderSouth
    boulderMiddle
    boulderNorthCave
    boulderNorthSlab
}

enum RouteType {
    BOULDER
    ROPE
}

model Route {
    id              String            @id @default(cuid())
    title           String
    setDate         DateTime          @default(now())
    color           String // Set a default color value
    grade           String
    communityGrades CommunityGrade[]
    images          RouteImage[]
    type            RouteType         @default(BOULDER)
    isArchive       Boolean           @default(false)
    xp              Int               @default(0) @db.SmallInt
    completions     RouteCompletion[] // One-to-many relationship with RouteCompletion
    attempts        RouteAttempt[] // One-to-many relationship with RouteAttemp
    tags            RouteTag[]
    location        Locations         @default(boulderSouth)
    stars           RouteStar[]
    createdByUserID String?
    createdByUser   User?             @relation("CreatedRoutes", fields: [createdByUserID], references: [id])
    order           Int?
    tvSlides        TVSlide[]
}

model RouteImage {
    id        String   @id @default(cuid())
    url       String // URL of the image
    route     Route    @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId   String
    createdAt DateTime @default(now())
}

model RouteCompletion {
    id             Int      @id @default(autoincrement())
    user           User     @relation(fields: [userId], references: [id])
    userId         String
    route          Route    @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId        String
    flash          Boolean  @default(false)
    completionDate DateTime @default(now())
    xpEarned       Int      @default(0) // Track XP earned for this specific completion

    @@index([userId, routeId]) // Remove unique constraint to allow multiple completions
}

model RouteStar {
    id       Int      @id @default(autoincrement())
    user     User     @relation(fields: [userId], references: [id])
    userId   String
    route    Route    @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId  String
    stars    Int
    comment  String?
    starDate DateTime @default(now())

    @@unique([userId, routeId])
}

model RouteAttempt {
    id          Int      @id @default(autoincrement())
    user        User     @relation(fields: [userId], references: [id])
    userId      String
    route       Route    @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId     String
    attempts    Int      @default(1)
    attemptDate DateTime @default(now())

    @@unique([userId, routeId])
}

model RouteTag {
    id     String  @id @default(cuid())
    name   String  @unique
    routes Route[]
}

model CommunityGrade {
    id        Int      @id @default(autoincrement())
    grade     String // The grade assigned by the user
    user      User     @relation(fields: [userId], references: [id])
    userId    String
    route     Route    @relation(fields: [routeId], references: [id], onDelete: Cascade)
    routeId   String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, routeId]) // Ensure only one grade per user per route
}

enum UserRole {
    ADMIN
    ROUTE_SETTER
    USER
}

model MonthlyXp {
    id        Int      @id @default(autoincrement())
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    month     Int
    year      Int
    xp        Int      @default(0) @db.SmallInt
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Ensure only one XP record per user per month/year
    @@unique([userId, month, year])
    // Add indexes for performance
    @@index([userId])
    @@index([year, month])
    @@index([userId, year, month])
}

model User {
    id                  String             @id @default(cuid())
    username            String?            @unique
    name                String?
    email               String             @unique
    emailVerified       DateTime?
    image               String?
    password            String?
    highestRopeGrade    String?
    highestBoulderGrade String?
    completions         RouteCompletion[] // One-to-many relationship with RouteCompletion
    attempts            RouteAttempt[] // One-to-many relationship with RouteAttempt
    communityGrades     CommunityGrade[]
    stars               RouteStar[]
    badges              Badge[]
    role                UserRole           @default(USER)
    createdAt           DateTime           @default(now())
    updatedAt           DateTime           @updatedAt
    Account             Account[]
    Session             Session[]
    createdRoutes       Route[]            @relation("CreatedRoutes")
    private             Boolean            @default(false)
    mixerClimber        MixerClimber[]
    blClimber           BLClimber[]
    isOnboarded         Boolean            @default(false)
    tag                 String?
    monthlyXp           MonthlyXp[]
    totalXp             Int                @default(0) @db.SmallInt
    seenAnnouncements   UserAnnouncement[]
}

model Announcement {
    id                String             @id @default(cuid())
    title             String
    body              String
    isActive          Boolean            @default(true)
    createdAt         DateTime           @default(now())
    updatedAt         DateTime           @updatedAt
    userAnnouncements UserAnnouncement[]
}

model UserAnnouncement {
    id             String       @id @default(cuid())
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
    announcementId String
    announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
    seenAt         DateTime     @default(now())

    @@unique([userId, announcementId]) // One record per user per announcement
    @@index([userId])
    @@index([announcementId])
}

enum TVSlideType {
    LEADERBOARD
    LOGO
    IMAGE
    TEXT
    STATS
    FEATURED_ROUTE
}

model TVSlide {
    id        String      @id @default(cuid())
    imageUrl  String?
    text      String?
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt
    isActive  Boolean     @default(true)
    routeId   String?
    route     Route?      @relation(fields: [routeId], references: [id])
    type      TVSlideType @default(IMAGE)

    @@index([routeId])
}

model Badge {
    id    Int    @id @default(autoincrement())
    name  String
    users User[]
}

model Account {
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([provider, providerAccountId])
}

model Session {
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@id([identifier, token])
}

enum EntryMethod {
    APP
    MANUAL
}

enum ClimberStatus {
    NOT_STARTED
    IN_PROGRESS
    COMPLETED
}

enum CompetitionStatus {
    INACTIVE
    UPCOMING
    IN_PROGRESS
    COMPLETED
    DEMO
    ARCHIVED
}

enum StandingsType {
    averageDownwardMovement
    downMovementByTop
}

enum CompletionType {
    BOULDER
    ROPE
}

//MIXER COMPETITION
model MixerCompetition {
    id                      String              @id @default(cuid())
    name                    String
    year                    Int
    status                  CompetitionStatus   @default(INACTIVE)
    imageUrl                String?
    time                    Int                 @default(180)
    compDay                 DateTime?
    passcode                String?
    mixerRoutes             MixerRoute[]
    boulder                 MixerBoulder[]
    climbers                MixerClimber[]
    divisions               MixerDivision[]
    boulderScores           MixerBoulderScore[]
    ropeScores              MixerRopeScore[]
    completions             MixerCompletion[]
    startedAt               DateTime?
    createdAt               DateTime            @default(now())
    updatedAt               DateTime            @updatedAt
    areScoresAvailable      Boolean             @default(false)
    isTestCompetition       Boolean             @default(false)
    hasScoresBeenCalculated Boolean             @default(false)
    standingsType           StandingsType?
    isBouldersReleased      Boolean             @default(false)
    isRoutesReleased        Boolean             @default(false)
}

model MixerRoute {
    id            String            @id @default(cuid())
    imageUrl      String?
    name          String
    color         String
    holds         Json // Array of { holdNumber, topRopePoints, leadPoints }
    competitionId String
    completions   MixerCompletion[]
    competition   MixerCompetition  @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    grade         String?
}

model MixerBoulder {
    id            String            @id @default(cuid())
    points        Int
    color         String
    competitionId String
    completions   MixerCompletion[]
    competition   MixerCompetition  @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    grade         String?
}

model MixerClimber {
    id            String              @id @default(cuid())
    name          String
    divisionId    String?
    division      MixerDivision?      @relation(fields: [divisionId], references: [id], onDelete: SetNull)
    boulderScores MixerBoulderScore[]
    ropeScores    MixerRopeScore[]
    competitionId String
    competition   MixerCompetition    @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    completions   MixerCompletion[]
    registeredAt  DateTime            @default(now()) // signup time
    entryMethod   EntryMethod         @default(MANUAL) // APP if linked to a user account
    climberStatus ClimberStatus       @default(NOT_STARTED) // not started, in progress, completed
    userId        String?
    user          User?               @relation(fields: [userId], references: [id])
    createdAt     DateTime            @default(now())
    updatedAt     DateTime            @updatedAt
}

model MixerDivision {
    id            String           @id @default(cuid())
    name          String
    climbers      MixerClimber[]
    competitionId String
    level         String?
    competition   MixerCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
}

model MixerBoulderScore {
    id            String           @id @default(cuid())
    climberId     String           @unique
    climber       MixerClimber     @relation(fields: [climberId], references: [id], onDelete: Cascade)
    score         Int
    attempts      Int
    competitionId String
    competition   MixerCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)

    @@unique([climberId, competitionId])
}

model MixerRopeScore {
    id            String           @id @default(cuid())
    climberId     String           @unique
    climber       MixerClimber     @relation(fields: [climberId], references: [id], onDelete: Cascade)
    score         Int
    attempts      Int
    competitionId String
    competition   MixerCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)

    @@unique([climberId, competitionId])
}

model MixerCompletion {
    id             String           @id @default(cuid())
    climberId      String
    climber        MixerClimber     @relation(fields: [climberId], references: [id], onDelete: Cascade)
    competitionId  String
    competition    MixerCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    type           CompletionType
    mixerRouteId   String?
    mixerRoute     MixerRoute?      @relation(fields: [mixerRouteId], references: [id])
    mixerBoulderId String?
    mixerBoulder   MixerBoulder?    @relation(fields: [mixerBoulderId], references: [id])
    attempts       Int
    points         Int
    holdNumber     Int?
    completionDate DateTime         @default(now())
    isComplete     Boolean?

    // Ensure a climber completes a specific route/boulder only once per competition
    @@unique([climberId, mixerRouteId])
    @@unique([climberId, mixerBoulderId])
}

//BOULDER LEAGUE
model BLCompetition {
    id                      String            @id @default(cuid())
    name                    String
    year                    Int
    status                  CompetitionStatus @default(INACTIVE)
    activeWeek              Int               @default(1)
    imageUrl                String?
    endDate                 DateTime?
    weekOneStartDate        DateTime?
    weekTwoStartDate        DateTime?
    weekThreeStartDate      DateTime?
    passcode                String?
    boulder                 BLBoulder[]
    climbers                BLClimber[]
    divisions               BLDivision[]
    boulderScores           BLBoulderScore[]
    completions             BLCompletion[]
    createdAt               DateTime          @default(now())
    updatedAt               DateTime          @updatedAt
    areScoresAvailable      Boolean           @default(false)
    isTestCompetition       Boolean           @default(false)
    hasScoresBeenCalculated Boolean           @default(false)
    standingsType           StandingsType?
    isBouldersReleased      Boolean           @default(false)
}

model BLBoulder {
    id            String         @id @default(cuid())
    points        Int
    week          Int
    color         String
    competitionId String
    completions   BLCompletion[]
    competition   BLCompetition  @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    grade         String?
}

model BLClimber {
    id            String           @id @default(cuid())
    name          String
    divisionId    String?
    division      BLDivision?      @relation(fields: [divisionId], references: [id], onDelete: SetNull)
    boulderScores BLBoulderScore[]
    competitionId String
    competition   BLCompetition    @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    completions   BLCompletion[]
    entryMethod   EntryMethod      @default(MANUAL) // APP if linked to a user account
    climberStatus ClimberStatus    @default(NOT_STARTED) // not started, in progress, completed
    userId        String?
    user          User?            @relation(fields: [userId], references: [id])
    createdAt     DateTime         @default(now())
    updatedAt     DateTime         @updatedAt
}

model BLBoulderScore {
    id            String        @id @default(cuid())
    climberId     String        @unique
    climber       BLClimber     @relation(fields: [climberId], references: [id], onDelete: Cascade)
    score         Int
    attempts      Int
    competitionId String
    competition   BLCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)

    @@unique([climberId, competitionId])
}

model BLDivision {
    id            String        @id @default(cuid())
    name          String
    climbers      BLClimber[]
    competitionId String
    level         String?
    competition   BLCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
}

model BLCompletion {
    id             String        @id @default(cuid())
    climberId      String
    climber        BLClimber     @relation(fields: [climberId], references: [id], onDelete: Cascade)
    competitionId  String
    competition    BLCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
    boulderId      String?
    boulder        BLBoulder?    @relation(fields: [boulderId], references: [id])
    attempts       Int
    points         Int
    completionDate DateTime      @default(now())
    isComplete     Boolean?

    // Ensure a climber completes a specific route/boulder only once per competition
    @@unique([climberId, boulderId])
}
