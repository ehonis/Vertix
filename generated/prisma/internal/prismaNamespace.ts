
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.1
 * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.1",
  engine: "55ae170b1ced7fc6ed07a15f110549408c501bb3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Route: 'Route',
  ClimbingSession: 'ClimbingSession',
  RouteImage: 'RouteImage',
  RouteCompletion: 'RouteCompletion',
  Bounty: 'Bounty',
  RouteStar: 'RouteStar',
  RouteAttempt: 'RouteAttempt',
  RouteTag: 'RouteTag',
  CommunityGrade: 'CommunityGrade',
  MonthlyXp: 'MonthlyXp',
  User: 'User',
  Announcement: 'Announcement',
  UserAnnouncement: 'UserAnnouncement',
  TVSlide: 'TVSlide',
  Badge: 'Badge',
  Account: 'Account',
  VerificationCode: 'VerificationCode',
  EmailVerificationCode: 'EmailVerificationCode',
  Session: 'Session',
  VerificationToken: 'VerificationToken',
  MixerCompetition: 'MixerCompetition',
  MixerRoute: 'MixerRoute',
  MixerBoulder: 'MixerBoulder',
  MixerClimber: 'MixerClimber',
  MixerDivision: 'MixerDivision',
  MixerBoulderScore: 'MixerBoulderScore',
  MixerRopeScore: 'MixerRopeScore',
  MixerCompletion: 'MixerCompletion',
  BLCompetition: 'BLCompetition',
  BLBoulder: 'BLBoulder',
  BLClimber: 'BLClimber',
  BLBoulderScore: 'BLBoulderScore',
  BLDivision: 'BLDivision',
  BLCompletion: 'BLCompletion'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "route" | "climbingSession" | "routeImage" | "routeCompletion" | "bounty" | "routeStar" | "routeAttempt" | "routeTag" | "communityGrade" | "monthlyXp" | "user" | "announcement" | "userAnnouncement" | "tVSlide" | "badge" | "account" | "verificationCode" | "emailVerificationCode" | "session" | "verificationToken" | "mixerCompetition" | "mixerRoute" | "mixerBoulder" | "mixerClimber" | "mixerDivision" | "mixerBoulderScore" | "mixerRopeScore" | "mixerCompletion" | "bLCompetition" | "bLBoulder" | "bLClimber" | "bLBoulderScore" | "bLDivision" | "bLCompletion"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Route: {
      payload: Prisma.$RoutePayload<ExtArgs>
      fields: Prisma.RouteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        findFirst: {
          args: Prisma.RouteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        findMany: {
          args: Prisma.RouteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>[]
        }
        create: {
          args: Prisma.RouteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        createMany: {
          args: Prisma.RouteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>[]
        }
        delete: {
          args: Prisma.RouteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        update: {
          args: Prisma.RouteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        deleteMany: {
          args: Prisma.RouteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>[]
        }
        upsert: {
          args: Prisma.RouteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutePayload>
        }
        aggregate: {
          args: Prisma.RouteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRoute>
        }
        groupBy: {
          args: Prisma.RouteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteCountAggregateOutputType> | number
        }
      }
    }
    ClimbingSession: {
      payload: Prisma.$ClimbingSessionPayload<ExtArgs>
      fields: Prisma.ClimbingSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ClimbingSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ClimbingSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        findFirst: {
          args: Prisma.ClimbingSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ClimbingSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        findMany: {
          args: Prisma.ClimbingSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>[]
        }
        create: {
          args: Prisma.ClimbingSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        createMany: {
          args: Prisma.ClimbingSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ClimbingSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>[]
        }
        delete: {
          args: Prisma.ClimbingSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        update: {
          args: Prisma.ClimbingSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        deleteMany: {
          args: Prisma.ClimbingSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ClimbingSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ClimbingSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>[]
        }
        upsert: {
          args: Prisma.ClimbingSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClimbingSessionPayload>
        }
        aggregate: {
          args: Prisma.ClimbingSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClimbingSession>
        }
        groupBy: {
          args: Prisma.ClimbingSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClimbingSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ClimbingSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClimbingSessionCountAggregateOutputType> | number
        }
      }
    }
    RouteImage: {
      payload: Prisma.$RouteImagePayload<ExtArgs>
      fields: Prisma.RouteImageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteImageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteImageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        findFirst: {
          args: Prisma.RouteImageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteImageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        findMany: {
          args: Prisma.RouteImageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>[]
        }
        create: {
          args: Prisma.RouteImageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        createMany: {
          args: Prisma.RouteImageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteImageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>[]
        }
        delete: {
          args: Prisma.RouteImageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        update: {
          args: Prisma.RouteImageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        deleteMany: {
          args: Prisma.RouteImageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteImageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteImageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>[]
        }
        upsert: {
          args: Prisma.RouteImageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteImagePayload>
        }
        aggregate: {
          args: Prisma.RouteImageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteImage>
        }
        groupBy: {
          args: Prisma.RouteImageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteImageGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteImageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteImageCountAggregateOutputType> | number
        }
      }
    }
    RouteCompletion: {
      payload: Prisma.$RouteCompletionPayload<ExtArgs>
      fields: Prisma.RouteCompletionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteCompletionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteCompletionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        findFirst: {
          args: Prisma.RouteCompletionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteCompletionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        findMany: {
          args: Prisma.RouteCompletionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>[]
        }
        create: {
          args: Prisma.RouteCompletionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        createMany: {
          args: Prisma.RouteCompletionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteCompletionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>[]
        }
        delete: {
          args: Prisma.RouteCompletionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        update: {
          args: Prisma.RouteCompletionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        deleteMany: {
          args: Prisma.RouteCompletionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteCompletionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteCompletionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>[]
        }
        upsert: {
          args: Prisma.RouteCompletionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteCompletionPayload>
        }
        aggregate: {
          args: Prisma.RouteCompletionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteCompletion>
        }
        groupBy: {
          args: Prisma.RouteCompletionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteCompletionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteCompletionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteCompletionCountAggregateOutputType> | number
        }
      }
    }
    Bounty: {
      payload: Prisma.$BountyPayload<ExtArgs>
      fields: Prisma.BountyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BountyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BountyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        findFirst: {
          args: Prisma.BountyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BountyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        findMany: {
          args: Prisma.BountyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>[]
        }
        create: {
          args: Prisma.BountyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        createMany: {
          args: Prisma.BountyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BountyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>[]
        }
        delete: {
          args: Prisma.BountyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        update: {
          args: Prisma.BountyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        deleteMany: {
          args: Prisma.BountyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BountyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BountyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>[]
        }
        upsert: {
          args: Prisma.BountyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        aggregate: {
          args: Prisma.BountyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBounty>
        }
        groupBy: {
          args: Prisma.BountyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyGroupByOutputType>[]
        }
        count: {
          args: Prisma.BountyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyCountAggregateOutputType> | number
        }
      }
    }
    RouteStar: {
      payload: Prisma.$RouteStarPayload<ExtArgs>
      fields: Prisma.RouteStarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteStarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteStarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        findFirst: {
          args: Prisma.RouteStarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteStarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        findMany: {
          args: Prisma.RouteStarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>[]
        }
        create: {
          args: Prisma.RouteStarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        createMany: {
          args: Prisma.RouteStarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteStarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>[]
        }
        delete: {
          args: Prisma.RouteStarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        update: {
          args: Prisma.RouteStarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        deleteMany: {
          args: Prisma.RouteStarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteStarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteStarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>[]
        }
        upsert: {
          args: Prisma.RouteStarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteStarPayload>
        }
        aggregate: {
          args: Prisma.RouteStarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteStar>
        }
        groupBy: {
          args: Prisma.RouteStarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteStarGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteStarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteStarCountAggregateOutputType> | number
        }
      }
    }
    RouteAttempt: {
      payload: Prisma.$RouteAttemptPayload<ExtArgs>
      fields: Prisma.RouteAttemptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteAttemptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteAttemptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        findFirst: {
          args: Prisma.RouteAttemptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteAttemptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        findMany: {
          args: Prisma.RouteAttemptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>[]
        }
        create: {
          args: Prisma.RouteAttemptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        createMany: {
          args: Prisma.RouteAttemptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteAttemptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>[]
        }
        delete: {
          args: Prisma.RouteAttemptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        update: {
          args: Prisma.RouteAttemptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        deleteMany: {
          args: Prisma.RouteAttemptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteAttemptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteAttemptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>[]
        }
        upsert: {
          args: Prisma.RouteAttemptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteAttemptPayload>
        }
        aggregate: {
          args: Prisma.RouteAttemptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteAttempt>
        }
        groupBy: {
          args: Prisma.RouteAttemptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteAttemptGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteAttemptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteAttemptCountAggregateOutputType> | number
        }
      }
    }
    RouteTag: {
      payload: Prisma.$RouteTagPayload<ExtArgs>
      fields: Prisma.RouteTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RouteTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RouteTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        findFirst: {
          args: Prisma.RouteTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RouteTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        findMany: {
          args: Prisma.RouteTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>[]
        }
        create: {
          args: Prisma.RouteTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        createMany: {
          args: Prisma.RouteTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RouteTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>[]
        }
        delete: {
          args: Prisma.RouteTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        update: {
          args: Prisma.RouteTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        deleteMany: {
          args: Prisma.RouteTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RouteTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RouteTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>[]
        }
        upsert: {
          args: Prisma.RouteTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RouteTagPayload>
        }
        aggregate: {
          args: Prisma.RouteTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRouteTag>
        }
        groupBy: {
          args: Prisma.RouteTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.RouteTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RouteTagCountAggregateOutputType> | number
        }
      }
    }
    CommunityGrade: {
      payload: Prisma.$CommunityGradePayload<ExtArgs>
      fields: Prisma.CommunityGradeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunityGradeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunityGradeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        findFirst: {
          args: Prisma.CommunityGradeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunityGradeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        findMany: {
          args: Prisma.CommunityGradeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>[]
        }
        create: {
          args: Prisma.CommunityGradeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        createMany: {
          args: Prisma.CommunityGradeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunityGradeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>[]
        }
        delete: {
          args: Prisma.CommunityGradeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        update: {
          args: Prisma.CommunityGradeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        deleteMany: {
          args: Prisma.CommunityGradeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunityGradeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunityGradeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>[]
        }
        upsert: {
          args: Prisma.CommunityGradeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityGradePayload>
        }
        aggregate: {
          args: Prisma.CommunityGradeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunityGrade>
        }
        groupBy: {
          args: Prisma.CommunityGradeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunityGradeGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunityGradeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunityGradeCountAggregateOutputType> | number
        }
      }
    }
    MonthlyXp: {
      payload: Prisma.$MonthlyXpPayload<ExtArgs>
      fields: Prisma.MonthlyXpFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MonthlyXpFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MonthlyXpFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        findFirst: {
          args: Prisma.MonthlyXpFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MonthlyXpFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        findMany: {
          args: Prisma.MonthlyXpFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>[]
        }
        create: {
          args: Prisma.MonthlyXpCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        createMany: {
          args: Prisma.MonthlyXpCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MonthlyXpCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>[]
        }
        delete: {
          args: Prisma.MonthlyXpDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        update: {
          args: Prisma.MonthlyXpUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        deleteMany: {
          args: Prisma.MonthlyXpDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MonthlyXpUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MonthlyXpUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>[]
        }
        upsert: {
          args: Prisma.MonthlyXpUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MonthlyXpPayload>
        }
        aggregate: {
          args: Prisma.MonthlyXpAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMonthlyXp>
        }
        groupBy: {
          args: Prisma.MonthlyXpGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MonthlyXpGroupByOutputType>[]
        }
        count: {
          args: Prisma.MonthlyXpCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MonthlyXpCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>
      fields: Prisma.AnnouncementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>
        }
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType> | number
        }
      }
    }
    UserAnnouncement: {
      payload: Prisma.$UserAnnouncementPayload<ExtArgs>
      fields: Prisma.UserAnnouncementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserAnnouncementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserAnnouncementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        findFirst: {
          args: Prisma.UserAnnouncementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserAnnouncementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        findMany: {
          args: Prisma.UserAnnouncementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>[]
        }
        create: {
          args: Prisma.UserAnnouncementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        createMany: {
          args: Prisma.UserAnnouncementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserAnnouncementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>[]
        }
        delete: {
          args: Prisma.UserAnnouncementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        update: {
          args: Prisma.UserAnnouncementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        deleteMany: {
          args: Prisma.UserAnnouncementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserAnnouncementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserAnnouncementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>[]
        }
        upsert: {
          args: Prisma.UserAnnouncementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnnouncementPayload>
        }
        aggregate: {
          args: Prisma.UserAnnouncementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserAnnouncement>
        }
        groupBy: {
          args: Prisma.UserAnnouncementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAnnouncementGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserAnnouncementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAnnouncementCountAggregateOutputType> | number
        }
      }
    }
    TVSlide: {
      payload: Prisma.$TVSlidePayload<ExtArgs>
      fields: Prisma.TVSlideFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TVSlideFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TVSlideFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        findFirst: {
          args: Prisma.TVSlideFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TVSlideFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        findMany: {
          args: Prisma.TVSlideFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>[]
        }
        create: {
          args: Prisma.TVSlideCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        createMany: {
          args: Prisma.TVSlideCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TVSlideCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>[]
        }
        delete: {
          args: Prisma.TVSlideDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        update: {
          args: Prisma.TVSlideUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        deleteMany: {
          args: Prisma.TVSlideDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TVSlideUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TVSlideUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>[]
        }
        upsert: {
          args: Prisma.TVSlideUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TVSlidePayload>
        }
        aggregate: {
          args: Prisma.TVSlideAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTVSlide>
        }
        groupBy: {
          args: Prisma.TVSlideGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TVSlideGroupByOutputType>[]
        }
        count: {
          args: Prisma.TVSlideCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TVSlideCountAggregateOutputType> | number
        }
      }
    }
    Badge: {
      payload: Prisma.$BadgePayload<ExtArgs>
      fields: Prisma.BadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        findFirst: {
          args: Prisma.BadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        findMany: {
          args: Prisma.BadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[]
        }
        create: {
          args: Prisma.BadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        createMany: {
          args: Prisma.BadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[]
        }
        delete: {
          args: Prisma.BadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        update: {
          args: Prisma.BadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        deleteMany: {
          args: Prisma.BadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[]
        }
        upsert: {
          args: Prisma.BadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>
        }
        aggregate: {
          args: Prisma.BadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBadge>
        }
        groupBy: {
          args: Prisma.BadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.BadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BadgeCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    VerificationCode: {
      payload: Prisma.$VerificationCodePayload<ExtArgs>
      fields: Prisma.VerificationCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        findFirst: {
          args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        findMany: {
          args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
        }
        create: {
          args: Prisma.VerificationCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        createMany: {
          args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
        }
        delete: {
          args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        update: {
          args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        deleteMany: {
          args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
        }
        upsert: {
          args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationCodePayload>
        }
        aggregate: {
          args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationCode>
        }
        groupBy: {
          args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationCodeCountAggregateOutputType> | number
        }
      }
    }
    EmailVerificationCode: {
      payload: Prisma.$EmailVerificationCodePayload<ExtArgs>
      fields: Prisma.EmailVerificationCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailVerificationCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailVerificationCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        findFirst: {
          args: Prisma.EmailVerificationCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailVerificationCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        findMany: {
          args: Prisma.EmailVerificationCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>[]
        }
        create: {
          args: Prisma.EmailVerificationCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        createMany: {
          args: Prisma.EmailVerificationCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailVerificationCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>[]
        }
        delete: {
          args: Prisma.EmailVerificationCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        update: {
          args: Prisma.EmailVerificationCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        deleteMany: {
          args: Prisma.EmailVerificationCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailVerificationCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailVerificationCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>[]
        }
        upsert: {
          args: Prisma.EmailVerificationCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationCodePayload>
        }
        aggregate: {
          args: Prisma.EmailVerificationCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailVerificationCode>
        }
        groupBy: {
          args: Prisma.EmailVerificationCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailVerificationCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationCodeCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    MixerCompetition: {
      payload: Prisma.$MixerCompetitionPayload<ExtArgs>
      fields: Prisma.MixerCompetitionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerCompetitionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerCompetitionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        findFirst: {
          args: Prisma.MixerCompetitionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerCompetitionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        findMany: {
          args: Prisma.MixerCompetitionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>[]
        }
        create: {
          args: Prisma.MixerCompetitionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        createMany: {
          args: Prisma.MixerCompetitionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerCompetitionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>[]
        }
        delete: {
          args: Prisma.MixerCompetitionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        update: {
          args: Prisma.MixerCompetitionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        deleteMany: {
          args: Prisma.MixerCompetitionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerCompetitionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerCompetitionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>[]
        }
        upsert: {
          args: Prisma.MixerCompetitionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompetitionPayload>
        }
        aggregate: {
          args: Prisma.MixerCompetitionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerCompetition>
        }
        groupBy: {
          args: Prisma.MixerCompetitionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerCompetitionGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerCompetitionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerCompetitionCountAggregateOutputType> | number
        }
      }
    }
    MixerRoute: {
      payload: Prisma.$MixerRoutePayload<ExtArgs>
      fields: Prisma.MixerRouteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerRouteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerRouteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        findFirst: {
          args: Prisma.MixerRouteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerRouteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        findMany: {
          args: Prisma.MixerRouteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>[]
        }
        create: {
          args: Prisma.MixerRouteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        createMany: {
          args: Prisma.MixerRouteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerRouteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>[]
        }
        delete: {
          args: Prisma.MixerRouteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        update: {
          args: Prisma.MixerRouteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        deleteMany: {
          args: Prisma.MixerRouteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerRouteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerRouteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>[]
        }
        upsert: {
          args: Prisma.MixerRouteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRoutePayload>
        }
        aggregate: {
          args: Prisma.MixerRouteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerRoute>
        }
        groupBy: {
          args: Prisma.MixerRouteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerRouteGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerRouteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerRouteCountAggregateOutputType> | number
        }
      }
    }
    MixerBoulder: {
      payload: Prisma.$MixerBoulderPayload<ExtArgs>
      fields: Prisma.MixerBoulderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerBoulderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerBoulderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        findFirst: {
          args: Prisma.MixerBoulderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerBoulderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        findMany: {
          args: Prisma.MixerBoulderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>[]
        }
        create: {
          args: Prisma.MixerBoulderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        createMany: {
          args: Prisma.MixerBoulderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerBoulderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>[]
        }
        delete: {
          args: Prisma.MixerBoulderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        update: {
          args: Prisma.MixerBoulderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        deleteMany: {
          args: Prisma.MixerBoulderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerBoulderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerBoulderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>[]
        }
        upsert: {
          args: Prisma.MixerBoulderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderPayload>
        }
        aggregate: {
          args: Prisma.MixerBoulderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerBoulder>
        }
        groupBy: {
          args: Prisma.MixerBoulderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerBoulderGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerBoulderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerBoulderCountAggregateOutputType> | number
        }
      }
    }
    MixerClimber: {
      payload: Prisma.$MixerClimberPayload<ExtArgs>
      fields: Prisma.MixerClimberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerClimberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerClimberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        findFirst: {
          args: Prisma.MixerClimberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerClimberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        findMany: {
          args: Prisma.MixerClimberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>[]
        }
        create: {
          args: Prisma.MixerClimberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        createMany: {
          args: Prisma.MixerClimberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerClimberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>[]
        }
        delete: {
          args: Prisma.MixerClimberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        update: {
          args: Prisma.MixerClimberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        deleteMany: {
          args: Prisma.MixerClimberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerClimberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerClimberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>[]
        }
        upsert: {
          args: Prisma.MixerClimberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerClimberPayload>
        }
        aggregate: {
          args: Prisma.MixerClimberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerClimber>
        }
        groupBy: {
          args: Prisma.MixerClimberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerClimberGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerClimberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerClimberCountAggregateOutputType> | number
        }
      }
    }
    MixerDivision: {
      payload: Prisma.$MixerDivisionPayload<ExtArgs>
      fields: Prisma.MixerDivisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerDivisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerDivisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        findFirst: {
          args: Prisma.MixerDivisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerDivisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        findMany: {
          args: Prisma.MixerDivisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>[]
        }
        create: {
          args: Prisma.MixerDivisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        createMany: {
          args: Prisma.MixerDivisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerDivisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>[]
        }
        delete: {
          args: Prisma.MixerDivisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        update: {
          args: Prisma.MixerDivisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        deleteMany: {
          args: Prisma.MixerDivisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerDivisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerDivisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>[]
        }
        upsert: {
          args: Prisma.MixerDivisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerDivisionPayload>
        }
        aggregate: {
          args: Prisma.MixerDivisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerDivision>
        }
        groupBy: {
          args: Prisma.MixerDivisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerDivisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerDivisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerDivisionCountAggregateOutputType> | number
        }
      }
    }
    MixerBoulderScore: {
      payload: Prisma.$MixerBoulderScorePayload<ExtArgs>
      fields: Prisma.MixerBoulderScoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerBoulderScoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerBoulderScoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        findFirst: {
          args: Prisma.MixerBoulderScoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerBoulderScoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        findMany: {
          args: Prisma.MixerBoulderScoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>[]
        }
        create: {
          args: Prisma.MixerBoulderScoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        createMany: {
          args: Prisma.MixerBoulderScoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerBoulderScoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>[]
        }
        delete: {
          args: Prisma.MixerBoulderScoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        update: {
          args: Prisma.MixerBoulderScoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        deleteMany: {
          args: Prisma.MixerBoulderScoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerBoulderScoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerBoulderScoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>[]
        }
        upsert: {
          args: Prisma.MixerBoulderScoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerBoulderScorePayload>
        }
        aggregate: {
          args: Prisma.MixerBoulderScoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerBoulderScore>
        }
        groupBy: {
          args: Prisma.MixerBoulderScoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerBoulderScoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerBoulderScoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerBoulderScoreCountAggregateOutputType> | number
        }
      }
    }
    MixerRopeScore: {
      payload: Prisma.$MixerRopeScorePayload<ExtArgs>
      fields: Prisma.MixerRopeScoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerRopeScoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerRopeScoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        findFirst: {
          args: Prisma.MixerRopeScoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerRopeScoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        findMany: {
          args: Prisma.MixerRopeScoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>[]
        }
        create: {
          args: Prisma.MixerRopeScoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        createMany: {
          args: Prisma.MixerRopeScoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerRopeScoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>[]
        }
        delete: {
          args: Prisma.MixerRopeScoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        update: {
          args: Prisma.MixerRopeScoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        deleteMany: {
          args: Prisma.MixerRopeScoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerRopeScoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerRopeScoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>[]
        }
        upsert: {
          args: Prisma.MixerRopeScoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerRopeScorePayload>
        }
        aggregate: {
          args: Prisma.MixerRopeScoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerRopeScore>
        }
        groupBy: {
          args: Prisma.MixerRopeScoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerRopeScoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerRopeScoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerRopeScoreCountAggregateOutputType> | number
        }
      }
    }
    MixerCompletion: {
      payload: Prisma.$MixerCompletionPayload<ExtArgs>
      fields: Prisma.MixerCompletionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MixerCompletionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MixerCompletionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        findFirst: {
          args: Prisma.MixerCompletionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MixerCompletionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        findMany: {
          args: Prisma.MixerCompletionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>[]
        }
        create: {
          args: Prisma.MixerCompletionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        createMany: {
          args: Prisma.MixerCompletionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MixerCompletionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>[]
        }
        delete: {
          args: Prisma.MixerCompletionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        update: {
          args: Prisma.MixerCompletionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        deleteMany: {
          args: Prisma.MixerCompletionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MixerCompletionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MixerCompletionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>[]
        }
        upsert: {
          args: Prisma.MixerCompletionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MixerCompletionPayload>
        }
        aggregate: {
          args: Prisma.MixerCompletionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMixerCompletion>
        }
        groupBy: {
          args: Prisma.MixerCompletionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerCompletionGroupByOutputType>[]
        }
        count: {
          args: Prisma.MixerCompletionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MixerCompletionCountAggregateOutputType> | number
        }
      }
    }
    BLCompetition: {
      payload: Prisma.$BLCompetitionPayload<ExtArgs>
      fields: Prisma.BLCompetitionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLCompetitionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLCompetitionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        findFirst: {
          args: Prisma.BLCompetitionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLCompetitionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        findMany: {
          args: Prisma.BLCompetitionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>[]
        }
        create: {
          args: Prisma.BLCompetitionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        createMany: {
          args: Prisma.BLCompetitionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLCompetitionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>[]
        }
        delete: {
          args: Prisma.BLCompetitionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        update: {
          args: Prisma.BLCompetitionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        deleteMany: {
          args: Prisma.BLCompetitionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLCompetitionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLCompetitionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>[]
        }
        upsert: {
          args: Prisma.BLCompetitionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompetitionPayload>
        }
        aggregate: {
          args: Prisma.BLCompetitionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLCompetition>
        }
        groupBy: {
          args: Prisma.BLCompetitionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLCompetitionGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLCompetitionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLCompetitionCountAggregateOutputType> | number
        }
      }
    }
    BLBoulder: {
      payload: Prisma.$BLBoulderPayload<ExtArgs>
      fields: Prisma.BLBoulderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLBoulderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLBoulderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        findFirst: {
          args: Prisma.BLBoulderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLBoulderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        findMany: {
          args: Prisma.BLBoulderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>[]
        }
        create: {
          args: Prisma.BLBoulderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        createMany: {
          args: Prisma.BLBoulderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLBoulderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>[]
        }
        delete: {
          args: Prisma.BLBoulderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        update: {
          args: Prisma.BLBoulderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        deleteMany: {
          args: Prisma.BLBoulderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLBoulderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLBoulderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>[]
        }
        upsert: {
          args: Prisma.BLBoulderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderPayload>
        }
        aggregate: {
          args: Prisma.BLBoulderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLBoulder>
        }
        groupBy: {
          args: Prisma.BLBoulderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLBoulderGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLBoulderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLBoulderCountAggregateOutputType> | number
        }
      }
    }
    BLClimber: {
      payload: Prisma.$BLClimberPayload<ExtArgs>
      fields: Prisma.BLClimberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLClimberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLClimberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        findFirst: {
          args: Prisma.BLClimberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLClimberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        findMany: {
          args: Prisma.BLClimberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>[]
        }
        create: {
          args: Prisma.BLClimberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        createMany: {
          args: Prisma.BLClimberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLClimberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>[]
        }
        delete: {
          args: Prisma.BLClimberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        update: {
          args: Prisma.BLClimberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        deleteMany: {
          args: Prisma.BLClimberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLClimberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLClimberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>[]
        }
        upsert: {
          args: Prisma.BLClimberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLClimberPayload>
        }
        aggregate: {
          args: Prisma.BLClimberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLClimber>
        }
        groupBy: {
          args: Prisma.BLClimberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLClimberGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLClimberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLClimberCountAggregateOutputType> | number
        }
      }
    }
    BLBoulderScore: {
      payload: Prisma.$BLBoulderScorePayload<ExtArgs>
      fields: Prisma.BLBoulderScoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLBoulderScoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLBoulderScoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        findFirst: {
          args: Prisma.BLBoulderScoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLBoulderScoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        findMany: {
          args: Prisma.BLBoulderScoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>[]
        }
        create: {
          args: Prisma.BLBoulderScoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        createMany: {
          args: Prisma.BLBoulderScoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLBoulderScoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>[]
        }
        delete: {
          args: Prisma.BLBoulderScoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        update: {
          args: Prisma.BLBoulderScoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        deleteMany: {
          args: Prisma.BLBoulderScoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLBoulderScoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLBoulderScoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>[]
        }
        upsert: {
          args: Prisma.BLBoulderScoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLBoulderScorePayload>
        }
        aggregate: {
          args: Prisma.BLBoulderScoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLBoulderScore>
        }
        groupBy: {
          args: Prisma.BLBoulderScoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLBoulderScoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLBoulderScoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLBoulderScoreCountAggregateOutputType> | number
        }
      }
    }
    BLDivision: {
      payload: Prisma.$BLDivisionPayload<ExtArgs>
      fields: Prisma.BLDivisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLDivisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLDivisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        findFirst: {
          args: Prisma.BLDivisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLDivisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        findMany: {
          args: Prisma.BLDivisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>[]
        }
        create: {
          args: Prisma.BLDivisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        createMany: {
          args: Prisma.BLDivisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLDivisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>[]
        }
        delete: {
          args: Prisma.BLDivisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        update: {
          args: Prisma.BLDivisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        deleteMany: {
          args: Prisma.BLDivisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLDivisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLDivisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>[]
        }
        upsert: {
          args: Prisma.BLDivisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLDivisionPayload>
        }
        aggregate: {
          args: Prisma.BLDivisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLDivision>
        }
        groupBy: {
          args: Prisma.BLDivisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLDivisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLDivisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLDivisionCountAggregateOutputType> | number
        }
      }
    }
    BLCompletion: {
      payload: Prisma.$BLCompletionPayload<ExtArgs>
      fields: Prisma.BLCompletionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BLCompletionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BLCompletionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        findFirst: {
          args: Prisma.BLCompletionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BLCompletionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        findMany: {
          args: Prisma.BLCompletionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>[]
        }
        create: {
          args: Prisma.BLCompletionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        createMany: {
          args: Prisma.BLCompletionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BLCompletionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>[]
        }
        delete: {
          args: Prisma.BLCompletionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        update: {
          args: Prisma.BLCompletionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        deleteMany: {
          args: Prisma.BLCompletionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BLCompletionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BLCompletionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>[]
        }
        upsert: {
          args: Prisma.BLCompletionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BLCompletionPayload>
        }
        aggregate: {
          args: Prisma.BLCompletionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBLCompletion>
        }
        groupBy: {
          args: Prisma.BLCompletionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLCompletionGroupByOutputType>[]
        }
        count: {
          args: Prisma.BLCompletionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BLCompletionCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const RouteScalarFieldEnum = {
  id: 'id',
  title: 'title',
  setDate: 'setDate',
  color: 'color',
  grade: 'grade',
  type: 'type',
  isArchive: 'isArchive',
  xp: 'xp',
  location: 'location',
  createdByUserID: 'createdByUserID',
  order: 'order',
  bonusXp: 'bonusXp',
  x: 'x',
  y: 'y'
} as const

export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


export const ClimbingSessionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  name: 'name',
  status: 'status',
  startedAt: 'startedAt',
  endedAt: 'endedAt',
  lastActivityAt: 'lastActivityAt',
  sessionDate: 'sessionDate',
  timeSlot: 'timeSlot',
  isRetroactive: 'isRetroactive',
  isCompetition: 'isCompetition',
  competitionType: 'competitionType',
  competitionId: 'competitionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ClimbingSessionScalarFieldEnum = (typeof ClimbingSessionScalarFieldEnum)[keyof typeof ClimbingSessionScalarFieldEnum]


export const RouteImageScalarFieldEnum = {
  id: 'id',
  url: 'url',
  routeId: 'routeId',
  createdAt: 'createdAt'
} as const

export type RouteImageScalarFieldEnum = (typeof RouteImageScalarFieldEnum)[keyof typeof RouteImageScalarFieldEnum]


export const RouteCompletionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  routeId: 'routeId',
  sessionId: 'sessionId',
  flash: 'flash',
  completionDate: 'completionDate',
  xpEarned: 'xpEarned',
  isCompetition: 'isCompetition',
  competitionType: 'competitionType',
  competitionId: 'competitionId'
} as const

export type RouteCompletionScalarFieldEnum = (typeof RouteCompletionScalarFieldEnum)[keyof typeof RouteCompletionScalarFieldEnum]


export const BountyScalarFieldEnum = {
  id: 'id',
  routeId: 'routeId',
  startedAt: 'startedAt',
  claimedAt: 'claimedAt',
  isActive: 'isActive',
  baseXp: 'baseXp',
  dailyIncrementXp: 'dailyIncrementXp',
  claimedByUserId: 'claimedByUserId',
  claimedOnCompletionId: 'claimedOnCompletionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BountyScalarFieldEnum = (typeof BountyScalarFieldEnum)[keyof typeof BountyScalarFieldEnum]


export const RouteStarScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  routeId: 'routeId',
  stars: 'stars',
  comment: 'comment',
  starDate: 'starDate'
} as const

export type RouteStarScalarFieldEnum = (typeof RouteStarScalarFieldEnum)[keyof typeof RouteStarScalarFieldEnum]


export const RouteAttemptScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  routeId: 'routeId',
  attempts: 'attempts',
  attemptDate: 'attemptDate'
} as const

export type RouteAttemptScalarFieldEnum = (typeof RouteAttemptScalarFieldEnum)[keyof typeof RouteAttemptScalarFieldEnum]


export const RouteTagScalarFieldEnum = {
  id: 'id',
  name: 'name'
} as const

export type RouteTagScalarFieldEnum = (typeof RouteTagScalarFieldEnum)[keyof typeof RouteTagScalarFieldEnum]


export const CommunityGradeScalarFieldEnum = {
  id: 'id',
  grade: 'grade',
  userId: 'userId',
  routeId: 'routeId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunityGradeScalarFieldEnum = (typeof CommunityGradeScalarFieldEnum)[keyof typeof CommunityGradeScalarFieldEnum]


export const MonthlyXpScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  month: 'month',
  year: 'year',
  xp: 'xp',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MonthlyXpScalarFieldEnum = (typeof MonthlyXpScalarFieldEnum)[keyof typeof MonthlyXpScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  username: 'username',
  name: 'name',
  phoneNumber: 'phoneNumber',
  email: 'email',
  emailVerified: 'emailVerified',
  image: 'image',
  password: 'password',
  highestRopeGrade: 'highestRopeGrade',
  highestBoulderGrade: 'highestBoulderGrade',
  role: 'role',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  private: 'private',
  isOnboarded: 'isOnboarded',
  tag: 'tag',
  totalXp: 'totalXp'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const AnnouncementScalarFieldEnum = {
  id: 'id',
  title: 'title',
  body: 'body',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


export const UserAnnouncementScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  announcementId: 'announcementId',
  seenAt: 'seenAt'
} as const

export type UserAnnouncementScalarFieldEnum = (typeof UserAnnouncementScalarFieldEnum)[keyof typeof UserAnnouncementScalarFieldEnum]


export const TVSlideScalarFieldEnum = {
  id: 'id',
  imageUrl: 'imageUrl',
  text: 'text',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isActive: 'isActive',
  routesId: 'routesId',
  type: 'type'
} as const

export type TVSlideScalarFieldEnum = (typeof TVSlideScalarFieldEnum)[keyof typeof TVSlideScalarFieldEnum]


export const BadgeScalarFieldEnum = {
  id: 'id',
  name: 'name'
} as const

export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


export const AccountScalarFieldEnum = {
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  access_token: 'access_token',
  expires_at: 'expires_at',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const VerificationCodeScalarFieldEnum = {
  phoneNumber: 'phoneNumber',
  code: 'code',
  expiresAt: 'expiresAt',
  attempts: 'attempts',
  createdAt: 'createdAt'
} as const

export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


export const EmailVerificationCodeScalarFieldEnum = {
  email: 'email',
  code: 'code',
  expiresAt: 'expiresAt',
  attempts: 'attempts',
  createdAt: 'createdAt'
} as const

export type EmailVerificationCodeScalarFieldEnum = (typeof EmailVerificationCodeScalarFieldEnum)[keyof typeof EmailVerificationCodeScalarFieldEnum]


export const SessionScalarFieldEnum = {
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const MixerCompetitionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  year: 'year',
  status: 'status',
  imageUrl: 'imageUrl',
  time: 'time',
  compDay: 'compDay',
  passcode: 'passcode',
  startedAt: 'startedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  areScoresAvailable: 'areScoresAvailable',
  isTestCompetition: 'isTestCompetition',
  hasScoresBeenCalculated: 'hasScoresBeenCalculated',
  standingsType: 'standingsType',
  isBouldersReleased: 'isBouldersReleased',
  isRoutesReleased: 'isRoutesReleased'
} as const

export type MixerCompetitionScalarFieldEnum = (typeof MixerCompetitionScalarFieldEnum)[keyof typeof MixerCompetitionScalarFieldEnum]


export const MixerRouteScalarFieldEnum = {
  id: 'id',
  imageUrl: 'imageUrl',
  name: 'name',
  color: 'color',
  holds: 'holds',
  competitionId: 'competitionId',
  grade: 'grade'
} as const

export type MixerRouteScalarFieldEnum = (typeof MixerRouteScalarFieldEnum)[keyof typeof MixerRouteScalarFieldEnum]


export const MixerBoulderScalarFieldEnum = {
  id: 'id',
  points: 'points',
  color: 'color',
  competitionId: 'competitionId',
  grade: 'grade'
} as const

export type MixerBoulderScalarFieldEnum = (typeof MixerBoulderScalarFieldEnum)[keyof typeof MixerBoulderScalarFieldEnum]


export const MixerClimberScalarFieldEnum = {
  id: 'id',
  name: 'name',
  divisionId: 'divisionId',
  competitionId: 'competitionId',
  registeredAt: 'registeredAt',
  entryMethod: 'entryMethod',
  climberStatus: 'climberStatus',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MixerClimberScalarFieldEnum = (typeof MixerClimberScalarFieldEnum)[keyof typeof MixerClimberScalarFieldEnum]


export const MixerDivisionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  competitionId: 'competitionId',
  level: 'level'
} as const

export type MixerDivisionScalarFieldEnum = (typeof MixerDivisionScalarFieldEnum)[keyof typeof MixerDivisionScalarFieldEnum]


export const MixerBoulderScoreScalarFieldEnum = {
  id: 'id',
  climberId: 'climberId',
  score: 'score',
  attempts: 'attempts',
  competitionId: 'competitionId'
} as const

export type MixerBoulderScoreScalarFieldEnum = (typeof MixerBoulderScoreScalarFieldEnum)[keyof typeof MixerBoulderScoreScalarFieldEnum]


export const MixerRopeScoreScalarFieldEnum = {
  id: 'id',
  climberId: 'climberId',
  score: 'score',
  attempts: 'attempts',
  competitionId: 'competitionId'
} as const

export type MixerRopeScoreScalarFieldEnum = (typeof MixerRopeScoreScalarFieldEnum)[keyof typeof MixerRopeScoreScalarFieldEnum]


export const MixerCompletionScalarFieldEnum = {
  id: 'id',
  climberId: 'climberId',
  competitionId: 'competitionId',
  type: 'type',
  mixerRouteId: 'mixerRouteId',
  mixerBoulderId: 'mixerBoulderId',
  attempts: 'attempts',
  points: 'points',
  holdNumber: 'holdNumber',
  completionDate: 'completionDate',
  isComplete: 'isComplete'
} as const

export type MixerCompletionScalarFieldEnum = (typeof MixerCompletionScalarFieldEnum)[keyof typeof MixerCompletionScalarFieldEnum]


export const BLCompetitionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  year: 'year',
  status: 'status',
  activeWeek: 'activeWeek',
  imageUrl: 'imageUrl',
  endDate: 'endDate',
  weekOneStartDate: 'weekOneStartDate',
  weekTwoStartDate: 'weekTwoStartDate',
  weekThreeStartDate: 'weekThreeStartDate',
  passcode: 'passcode',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  areScoresAvailable: 'areScoresAvailable',
  isTestCompetition: 'isTestCompetition',
  hasScoresBeenCalculated: 'hasScoresBeenCalculated',
  standingsType: 'standingsType',
  isBouldersReleased: 'isBouldersReleased'
} as const

export type BLCompetitionScalarFieldEnum = (typeof BLCompetitionScalarFieldEnum)[keyof typeof BLCompetitionScalarFieldEnum]


export const BLBoulderScalarFieldEnum = {
  id: 'id',
  points: 'points',
  week: 'week',
  color: 'color',
  competitionId: 'competitionId',
  grade: 'grade'
} as const

export type BLBoulderScalarFieldEnum = (typeof BLBoulderScalarFieldEnum)[keyof typeof BLBoulderScalarFieldEnum]


export const BLClimberScalarFieldEnum = {
  id: 'id',
  name: 'name',
  divisionId: 'divisionId',
  competitionId: 'competitionId',
  entryMethod: 'entryMethod',
  climberStatus: 'climberStatus',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BLClimberScalarFieldEnum = (typeof BLClimberScalarFieldEnum)[keyof typeof BLClimberScalarFieldEnum]


export const BLBoulderScoreScalarFieldEnum = {
  id: 'id',
  climberId: 'climberId',
  score: 'score',
  attempts: 'attempts',
  competitionId: 'competitionId'
} as const

export type BLBoulderScoreScalarFieldEnum = (typeof BLBoulderScoreScalarFieldEnum)[keyof typeof BLBoulderScoreScalarFieldEnum]


export const BLDivisionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  competitionId: 'competitionId',
  level: 'level'
} as const

export type BLDivisionScalarFieldEnum = (typeof BLDivisionScalarFieldEnum)[keyof typeof BLDivisionScalarFieldEnum]


export const BLCompletionScalarFieldEnum = {
  id: 'id',
  climberId: 'climberId',
  competitionId: 'competitionId',
  boulderId: 'boulderId',
  attempts: 'attempts',
  points: 'points',
  completionDate: 'completionDate',
  isComplete: 'isComplete'
} as const

export type BLCompletionScalarFieldEnum = (typeof BLCompletionScalarFieldEnum)[keyof typeof BLCompletionScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'RouteType'
 */
export type EnumRouteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteType'>
    


/**
 * Reference to a field of type 'RouteType[]'
 */
export type ListEnumRouteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteType[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Locations'
 */
export type EnumLocationsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Locations'>
    


/**
 * Reference to a field of type 'Locations[]'
 */
export type ListEnumLocationsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Locations[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'SessionType'
 */
export type EnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType'>
    


/**
 * Reference to a field of type 'SessionType[]'
 */
export type ListEnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType[]'>
    


/**
 * Reference to a field of type 'SessionStatus'
 */
export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


/**
 * Reference to a field of type 'SessionStatus[]'
 */
export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


/**
 * Reference to a field of type 'CompetitionType'
 */
export type EnumCompetitionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetitionType'>
    


/**
 * Reference to a field of type 'CompetitionType[]'
 */
export type ListEnumCompetitionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetitionType[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'TVSlideType'
 */
export type EnumTVSlideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVSlideType'>
    


/**
 * Reference to a field of type 'TVSlideType[]'
 */
export type ListEnumTVSlideTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVSlideType[]'>
    


/**
 * Reference to a field of type 'CompetitionStatus'
 */
export type EnumCompetitionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetitionStatus'>
    


/**
 * Reference to a field of type 'CompetitionStatus[]'
 */
export type ListEnumCompetitionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetitionStatus[]'>
    


/**
 * Reference to a field of type 'StandingsType'
 */
export type EnumStandingsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandingsType'>
    


/**
 * Reference to a field of type 'StandingsType[]'
 */
export type ListEnumStandingsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandingsType[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'EntryMethod'
 */
export type EnumEntryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryMethod'>
    


/**
 * Reference to a field of type 'EntryMethod[]'
 */
export type ListEnumEntryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryMethod[]'>
    


/**
 * Reference to a field of type 'ClimberStatus'
 */
export type EnumClimberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClimberStatus'>
    


/**
 * Reference to a field of type 'ClimberStatus[]'
 */
export type ListEnumClimberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClimberStatus[]'>
    


/**
 * Reference to a field of type 'CompletionType'
 */
export type EnumCompletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletionType'>
    


/**
 * Reference to a field of type 'CompletionType[]'
 */
export type ListEnumCompletionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletionType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  route?: Prisma.RouteOmit
  climbingSession?: Prisma.ClimbingSessionOmit
  routeImage?: Prisma.RouteImageOmit
  routeCompletion?: Prisma.RouteCompletionOmit
  bounty?: Prisma.BountyOmit
  routeStar?: Prisma.RouteStarOmit
  routeAttempt?: Prisma.RouteAttemptOmit
  routeTag?: Prisma.RouteTagOmit
  communityGrade?: Prisma.CommunityGradeOmit
  monthlyXp?: Prisma.MonthlyXpOmit
  user?: Prisma.UserOmit
  announcement?: Prisma.AnnouncementOmit
  userAnnouncement?: Prisma.UserAnnouncementOmit
  tVSlide?: Prisma.TVSlideOmit
  badge?: Prisma.BadgeOmit
  account?: Prisma.AccountOmit
  verificationCode?: Prisma.VerificationCodeOmit
  emailVerificationCode?: Prisma.EmailVerificationCodeOmit
  session?: Prisma.SessionOmit
  verificationToken?: Prisma.VerificationTokenOmit
  mixerCompetition?: Prisma.MixerCompetitionOmit
  mixerRoute?: Prisma.MixerRouteOmit
  mixerBoulder?: Prisma.MixerBoulderOmit
  mixerClimber?: Prisma.MixerClimberOmit
  mixerDivision?: Prisma.MixerDivisionOmit
  mixerBoulderScore?: Prisma.MixerBoulderScoreOmit
  mixerRopeScore?: Prisma.MixerRopeScoreOmit
  mixerCompletion?: Prisma.MixerCompletionOmit
  bLCompetition?: Prisma.BLCompetitionOmit
  bLBoulder?: Prisma.BLBoulderOmit
  bLClimber?: Prisma.BLClimberOmit
  bLBoulderScore?: Prisma.BLBoulderScoreOmit
  bLDivision?: Prisma.BLDivisionOmit
  bLCompletion?: Prisma.BLCompletionOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

